<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport"
	content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>canvas</title>
<link rel="stylesheet" href="./css/jquery.mobile-1.2.0.min.css" />
<style type="text/css"> 
	#can{ width:300px; height:500px; border:1px solid #ccc; margin-top:0px; margin-left:20px;}
</style>
<script src="./js/jquery-1.8.2.min.js"></script>
<script src="./js/jquery.mobile-1.2.0.min.js"></script>
<script type="text/javascript" src="./js/util.js"></script>
<script>/*
	function init(){
		$("#can").bind("tap",function(){
			console.log("tap..");
		});
		
		$("#can").bind("vmousedown",function(){
			console.log("vmousedown..");
		});
		
		$("#can").bind("vmouseout",function(){
			console.log("vmouseout..");
		});
		
		$("#can").bind("vmouseover",function(){
			console.log("vmouseover..");
		});
		
		$("#can").bind("vmousemove",function(e){
			console.log("vmousemove..;top="+getBodyOffsetTop(e).y);
		});
		
		$("#can").bind("vmouseup",function(){
			console.log("vmouseup..");
		});
		
	}*/
	var drawer;
	function init(){
		drawer = new Drawing('can');
	}
	$(document).ready(init);
	
	function getBodyOffset(e){
		var x,y;
		var e = e||window.event;
		return{x:e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,y:e.clientY+document.body.scrollTop+document.documentElement.scrollTop};
	} 

	function Drawing(canvas, options) {
		typeof canvas == 'string' && (canvas = document.getElementById(canvas));
		if (!canvas || !canvas.getContext) {
			alert("do not support canvas!");
		}
		this.option = {
			colors : [ '#000000', '#ff0000', '#00ff00', '#0000ff', '#00ffff',
					'#7fef02', '#4488bb' ]
		};
		this.setOption(options);
		this.init(canvas);
	}

	Drawing.prototype = {
		setOption : function(options) {
			typeof options == 'object' || (options = {});
			for ( var i in options) {
				switch (i) {
				case 'colors':
					this.option[i] = options[i];
					break;
				}
			}
		},
		init:function(canvas){
			this.type_line = 0;
			this.type_text=1;
			this.type_eraser=2;
			this.type_clear=3;
			this.type_back=4;
			this.type_forward=5;
			this.canvas = canvas;
			this.context = canvas.getContext('2d'); 
			this.context.lineWidth = 1; 
			this.context.lineJons = 'round'; 
			this.context.lineCep = 'round'; 
			this.isButtonDown = false;
			this.historyStroker = []; 
			this.curStroker = {color:'#000000',path:[],type:this.type_line,time:util.currentTimeMillis()}; 
			this.lastX = 0; 
			this.lastY = 0; 
			this.curColor = '#000000'; 
			this.curDrawingType=this.type_line;
			this.toolbarspos ={}; 
			this.bindEvent(); 
			this.ResetDrawToolbar(); 
			this.lastIndex=0;
		},
		bindEvent:function(){
			console.log("bindEvent() called."); 
			var self = this; 
			
			$("#can").bind("vmousemove",function(e){
				//console.log("vmousemove..");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseMove({x:x,y:y}); 
			});
			$("#can").bind("vmousedown",function(e){
				console.log("vmousedown() called.");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseDown(event,{x:x,y:y}); 
			});
			
			$("#can").bind("vmouseup",function(e){
				console.log("vmouseup() called.");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseUp(event,{x:x,y:y});	
			});
			
			$("#can").bind("vclick",function(e){
				console.log("vclick() called.");
				var xy = getBodyOffset(e);
				
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				
				self.onClick({x:x,y:y}); 	
			});
		},
		onMouseMove:function(pos){ 
			//console.log("onMouseMove() called.x="+pos.x+";y="+pos.y);
			if(this.isButtonDown){ 
				var p = this.toolbarspos; 
				for(var i in p){  
					if(pos.x >= p[i].x 
					&& pos.x <= p[i].x+p[i].w 
					&& pos.y >= p[i].y 
					&& pos.y <= p[i].y+p[i].h){return;} 
				}
				if(this.curDrawingType == this.type_line){
					this.context.lineTo(pos.x,pos.y); 
					this.context.stroke(); 	
				}else if(this.curDrawingType == this.type_eraser){	
					this.context.clearRect(pos.x,pos.y,5,5);
				}else if(this.curDrawingType == this.type_clear){
					this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height"));
					return;
				}else if(this.curDrawingType == this.type_text){
					updateCanTxtPos(pos);
					this.lastX = pos.x; 
					this.lastY = pos.y;
					return;
				} 
				
				this.lastX = pos.x; 
				this.lastY = pos.y; 
				this.curStroker.path.push(pos); 
			} 
		},
		onMouseDown:function(event,pos){ 
		console.log("onMouseDown() called.");
		
			if(this.curDrawingType == this.type_clear){
					return;
			} 
			 
			var p = this.toolbarspos; 
			for(var i in p){ 
				if(pos.x >= p[i].x 
				&& pos.x <= p[i].x+p[i].w 
				&& pos.y >= p[i].y 
				&& pos.y <= p[i].y+p[i].h){ 
					return; 
				} 
			} 
			this.isButtonDown = true; 
			
			this.lastX = pos.x; 
			this.lastY = pos.y; 
			this.context.beginPath(); 
			this.context.moveTo(this.lastX,this.lastY);
			this.curStroker.type = this.curDrawingType;
			this.curStroker.color = this.curColor; 
			this.curStroker.path.push(pos); 
			 
		},onMouseUp:function(event,pos){ 
		console.log("onMouseUp() called.");
			
			if(this.curDrawingType == this.type_clear||this.curDrawingType == this.type_text){
					return;
			}  
			 
			var p = this.toolbarspos; 
			for(var i in p){ 
				if(pos.x >= p[i].x 
				&& pos.x <= p[i].x+p[i].w 
				&& pos.y >= p[i].y 
				&& pos.y <= p[i].y+p[i].h){return;} 
			} 
			this.isButtonDown = false; 
			
			this.historyStroker.push(this.curStroker); 
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:0}; 
			
		},
		ResetDrawAll:function(){ 
		//console.log("ResetDrawAll() called.");
			this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height")); 
			this.ResetDrawCentre(); 
			this.ResetDrawToolbar(); 
		}, 
		ResetDrawCentre:function(){
		//console.log("ResetDrawCentre() called.");  
			var p = this.historyStroker,p2,
			curColor = this.context.strokeStyle;
			var strokers = new Array();
			var data =  new Array();
			for(var i=0; i< p.length;i++){
				if(p[i].type == this.type_back){
					strokers.pop();						
				}else if(p[i].type == this.type_forward){
					data =  new Array();
					var count_back = 0;
					var count_forward = 0;
					var index_content = 0;
					for(var k=i;k>=0;k--){
						if(p[k].type == this.type_back){
							count_back++;	
						}else if(p[k].type == this.type_forward){
							count_forward++;	
						}else{
							index_content =k;
							break;
						}
					}
					
					for(var j=0;j<=index_content;j++){
						data.push(p[j]);
					}
					
					var c = count_back-count_forward;
					
					index_content = index_content + 1;
					for(var m =0;m<c;m++){
						data.push(p[m+index_content]);
					}
					strokers = this.executeDraw(data);
					//strokers = strokers.reverse();
					//alert(strokers.length);
					continue;
				}else{
					strokers.push(p[i]);
				}
				this.ResetDrawCentreForDisplay(strokers);
			} 
			this.context.strokeStyle = curColor; 
		},
		executeDraw:function(data){
		//console.log("executeDraw called.data.length="+data.length);  
		if(data.length==0)this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height"));
			var p = data,p2,
			curColor = this.context.strokeStyle;
			var strokers = new Array();
			
			var _data = new Array();
			for(var i=0; i< p.length;i++){
				if(p[i].type == this.type_back){
					strokers.pop();						
				}else if(p[i].type == this.type_forward){
					_data = new Array();
					var count_back = 0;
					var count_forward = 0;
					var index_content = 0;
					for(var k=i;k>=0;k--){
						if(p[k].type == this.type_back){
							count_back++;	
						}else if(p[k].type == this.type_forward){
							count_forward++;	
						}else{
							index_content =k;
							break;
						}
					}
					
					for(var j=0;j<=index_content;j++){
						_data.push(p[j]);
					}
					var c = count_back-count_forward;
					
					index_content = index_content + 1;
					for(var m =0;m<c;m++){
						_data.push(p[m+index_content]);
					}
					
					var ch = this.executeDraw(_data);
					strokers = ch;
					/*
					for(var n=0;n<ch.length;n++){
						strokers.push(ch[n]);
					}*/
					continue;
				}else{
					strokers.push(p[i]);
				}
				this.ResetDrawCentreForDisplay(strokers);
			} 
			this.context.strokeStyle = curColor;
			return strokers; 
		}
		,
		ResetDrawCentreForDisplay:function(data){
//		console.log("ResetDrawCentreForDisplay() called.data.length="+data.length);
		this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height"));  
			var p = data,p2, 
			curColor = this.context.strokeStyle; 
			for(var i=0; i< p.length;i++){
				
				if(p[i].type == this.type_clear){
					this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height"));
					continue;
				}else if(p[i].type == this.type_text){
					this.context.fillText(p[i].text,p[i].position.x,p[i].position.y);
					continue;
				}
			 
				this.context.strokeStyle = p[i].color; 
				this.context.beginPath(); 
				for(var t=0; t<p[i].path.length;t++){ 
					p2 = p[i].path[t]; 
					if(t==0) this.context.moveTo(p2.x,p2.y);
					 
						if(p[i].type == this.type_line){
							this.context.lineTo(p2.x,p2.y); 
							this.context.stroke();  	
						}else if(p[i].type == this.type_eraser){
							this.context.clearRect(p2.x,p2.y,5,5);
							this.context.stroke();  
						}else if(p[i].type == this.type_text){
							//console.log(p[i].text+";"+p[i].position.x+";"+p[i].position.y);
							this.context.fillText(p[i].text,p[i].position.x,p[i].position.y);
						}					 
				}
				this.context.beginPath(); 
			} 
			this.context.strokeStyle = curColor;
			
		},
		ResetDrawToolbar:function(){
		//console.log("ResetDrawToolbar() called."); 
			var curcolor = this.context.fillStyle; 
			
			for(var i=0; i<this.option.colors.length;i++){ 
				this.context.fillStyle = this.option.colors[i]; 
				if(this.curColor == this.context.fillStyle){ 
					this.context.fillRect(i*35+5,2,30,20); 
					this.toolbarspos[i] ={x:i*35+5,y:2,w:30,h:20}; 
				}else{ 
					this.context.fillRect(i*35+5,5,30,20); 
					this.toolbarspos[i] = {x:i*35+5,y:5,w:30,h:20}; 
				} 
				this.context.stroke(); 
			} 
			this.context.fillStyle = curcolor;
			
		},
		onClick:function(pos){
			console.log("onClick() called.");
			var p = this.toolbarspos; 
			for(var i in p){ 
			if(pos.x >= p[i].x 
			&& pos.x <= p[i].x+p[i].w 
			&& pos.y >= p[i].y 
			&& pos.y <= p[i].y+p[i].h){ 
				this.curColor = this.option.colors[i];
				this.curDrawingType = this.type_line;
				this.context.strokeStyle = this.curColor; 
				this.ResetDrawAll(); 
				} 
			} 
		},
		onPen:function(){
			console.log("onPen called.");
			this.curDrawingType = this.type_line;
			this.context.strokeStyle = this.curColor; 
			this.ResetDrawAll();
		}
		,
		onEraser:function(){
			console.log("onEraser called.");
			this.curDrawingType = this.type_eraser;
		},
		onClear:function(){
			console.log("onClear called.");
			this.context.beginPath();
			this.curDrawingType = this.type_clear;
			this.curStroker.type = this.curDrawingType;
			this.curStroker.time = util.currentTimeMillis();
			this.historyStroker.push(this.curStroker);
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:this.curStroker.time};
			this.context.clearRect(0,0,$("#can").attr("width"),$("#can").attr("height"));
			this.ResetDrawToolbar();
			//this.ResetDrawAll();
		},
		onUndo:function(){
			console.log("onUndo called.");
			
			if(!this.checkUndo())return;
			
			this.curDrawingType = this.type_back;
			this.curStroker.type = this.curDrawingType;
			this.curStroker.time = util.currentTimeMillis();
			this.historyStroker.push(this.curStroker);
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:this.curStroker.time};
			this.ResetDrawAll();
		},
		onRedo: function(){
			console.log("onRedo called.");
			
			if(!this.checkRedo())return;
			
			this.curDrawingType = this.type_forward;
			this.curStroker.type = this.curDrawingType;
			this.curStroker.time = util.currentTimeMillis();
			this.historyStroker.push(this.curStroker);
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:this.curStroker.time};
			this.ResetDrawAll();
		},
		onInputTxt: function(){
			console.log("onInputTxt called.");
			this.curDrawingType = this.type_text;
			this.curStroker.type = this.curDrawingType;
			this.curStroker.time = util.currentTimeMillis();
			//this.historyStroker.push(this.curStroker);
			//this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:this.curStroker.time,position:{x:0,y:0},text:""};
		},
		onExecuteInputText: function(){
			console.log("onExecuteInputText called.");
			
			this.context.fillText($("#c_input_txt").html(),this.lastX,this.lastY);
			this.curStroker.position = {x:this.lastX,y:this.lastY};
			this.curStroker.text = $("#c_input_txt").html();
			console.log("gggggg==::"+this.curStroker.text+";"+this.curStroker.position.x+";"+this.curStroker.position.y);
			this.historyStroker.push(this.curStroker);
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:this.curStroker.time,position:{x:0,y:0},text:""};
		}
		,
		checkUndo: function(){
			var p = this.historyStroker;
			var count_back=0;
			var count_content=0;
			var f_back = false;
			var f_content = false;
			
			for(var i=p.length-1; i>=0;i--){
				if(p[i].type == this.type_back&&!f_content){
					count_back++;
				}else if(p[i].type == this.type_back&&f_content){
					break;
				}else if(p[i].type == this.type_forward){
					count_back--;
				}else{
					f_content=true;
					if(!f_back)
						count_content++;
				}
			}
			
			if(count_back<count_content)
				return true;
			else
				return false;
		},
		checkRedo: function(){
			var p = this.historyStroker;
			var count_back=0;
			var count_forward=0;
			var count_content=0;
			var f_forward = false;
			var f_back = false;
			var f_content = false;
			
			for(var i=p.length-1; i>=0;i--){
				if(p[i].type == this.type_forward&&!f_forward){
					count_forward++;
				}else if(p[i].type == this.type_back){
					count_back++;
					f_forward=true;
				}else{
					break;
				}
			}
			if(count_forward<=count_back)
				return true;
			else
				return false;
		}
	};
	
	function eraserOn(){
		console.log("eraserOn() called.");
		drawer.onEraser();
	}
	
	function clear(){
		console.log("clear() called.");
		drawer.onClear();
	}
	
	function undo(){
		console.log("undo() called.");
		drawer.onUndo();
	}
	
	function redo(){
		console.log("redo() called.");
		drawer.onRedo();
	}
	
	function putText(){
		console.log("putText() called.");
		$("#div_can_txt").show();
	}
	
	function fireCanTxt(){
		console.log("fireCanTxt() called.");
		$("#c_input_txt_container").show();
		drawer.onInputTxt();		
		$("#c_input_txt").html($("#can_txt").val());
		$("#div_can_txt").hide();
	}
	
	function updateCanTxtPos(xy){
		$("#c_input_txt_container").css("left",xy.x);
		$("#c_input_txt_container").css("top",xy.y);
	}
	
	function cancelCanTxt(){
		console.log("cancelCanTxt() called.");
		$("#div_can_txt").hide();
	}
	
	function cancelInputTxt(){
		$("#c_input_txt_container").hide();
		$("#div_can_txt").show();
	}
	
	function executeInputTxt(){
		$("#c_input_txt_container").hide();
		drawer.onExecuteInputText();
		$("#c_input_txt").val("");
		$("#can_txt").val("");
	}
	
	function penOn(){
		console.log("penOn() called.");
		drawer.onPen();
	}
	
</script>
</head>
<body >
	<h2 style="padding-left: 20px">canvas</h2>
	<canvas id="can" width="300" height="500" ></canvas>
	<div>
		<a href="javascript:penOn();"> <img src="./css/images/draw_off.png" /></a>
		<a href="javascript:eraserOn();"> <img src="./css/images/eraser_off.png" /></a>
		<a href="javascript:clear();"> <img src="./css/images/erase_all.png" /></a>
		<a href="javascript:undo();"> <img src="./css/images/undo_arrow.png" /></a>
		<a href="javascript:redo();"> <img src="./css/images/redo_arrow.png" /></a>
		<a href="javascript:putText();"> <img src="./css/images/text_off.png" /></a>
	</div>
	<div id="div_can_txt" style="display:none;">
		<input type="text" id="can_txt" name="can_txt" />
		<input type="button" value="ok" onclick="fireCanTxt()" />
		<input type="button" value="cancel" onclick="cancelCanTxt()"  />
	</div>
	<div id="c_input_txt_container" style="position:absolute;display:none;">
		<div id="c_input_txt"></div>
		<div>[put here?]</div>
		<div>
			<input type="button" value="ok" onclick="executeInputTxt()" />
			<input type="button" value="cancel" onclick="cancelInputTxt()"  />
		</div>
	</div>
</body>
</html>