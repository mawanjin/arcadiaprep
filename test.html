<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport"
	content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>canvas</title>
<link rel="stylesheet" href="./css/jquery.mobile-1.2.0.min.css" />
<style type="text/css"> 
	#can{ width:300px; height:500px; border:1px solid #ccc; margin-top:0px; margin-left:20px;}
</style>
<script src="./js/jquery-1.8.2.min.js"></script>
<script src="./js/jquery.mobile-1.2.0.min.js"></script>
<script type="text/javascript" src="./js/util.js"></script>
<script>/*
	function init(){
		$("#can").bind("tap",function(){
			console.log("tap..");
		});
		
		$("#can").bind("vmousedown",function(){
			console.log("vmousedown..");
		});
		
		$("#can").bind("vmouseout",function(){
			console.log("vmouseout..");
		});
		
		$("#can").bind("vmouseover",function(){
			console.log("vmouseover..");
		});
		
		$("#can").bind("vmousemove",function(e){
			console.log("vmousemove..;top="+getBodyOffsetTop(e).y);
		});
		
		$("#can").bind("vmouseup",function(){
			console.log("vmouseup..");
		});
		
	}*/
	var drawer;
	function init(){
		drawer = new Drawing('can');
	}
	$(document).ready(init);
	
	function getBodyOffset(e){
		var x,y;
		var e = e||window.event;
		return{x:e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,y:e.clientY+document.body.scrollTop+document.documentElement.scrollTop};
	} 

	function Drawing(canvas, options) {
		typeof canvas == 'string' && (canvas = document.getElementById(canvas));
		if (!canvas || !canvas.getContext) {
			alert("do not support canvas!");
		}
		this.option = {
			colors : [ '#000000', '#ff0000', '#00ff00', '#0000ff', '#00ffff',
					'#7fef02', '#4488bb' ]
		};
		this.setOption(options);
		this.init(canvas);
	}

	Drawing.prototype = {
		setOption : function(options) {
			typeof options == 'object' || (options = {});
			for ( var i in options) {
				switch (i) {
				case 'colors':
					this.option[i] = options[i];
					break;
				}
			}
		},
		init:function(canvas){
			this.type_line = 0;
			this.type_text=1;
			this.type_eraser=2;
			this.type_clear=3;
			this.type_back=4;
			this.type_forward=5;
			this.canvas = canvas;
			this.context = canvas.getContext('2d'); 
			this.context.lineWidth = 1; 
			this.context.lineJons = 'round'; 
			this.context.lineCep = 'round'; 
			this.isButtonDown = false;
			this.historyStroker = []; 
			this.curStroker = {color:'#000000',path:[],type:this.type_line,time:util.currentTimeMillis()}; 
			this.lastX = 0; 
			this.lastY = 0; 
			this.curColor = '#000000'; 
			this.curDrawingType=this.type_line;
			this.toolbarspos ={}; 
			this.bindEvent(); 
			this.ResetDrawToolbar(); 
		},
		bindEvent:function(){
			console.log("bindEvent() called."); 
			var self = this; 
			
			$("#can").bind("vmousemove",function(e){
				console.log("vmousemove..");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseMove({x:x,y:y}); 
			});
			$("#can").bind("vmousedown",function(e){
				console.log("vmousedown() called.");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseDown(event,{x:x,y:y}); 
			});
			
			$("#can").bind("vmouseup",function(e){
				console.log("vmouseup() called.");
				var xy = getBodyOffset(e);
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				self.onMouseUp(event,{x:x,y:y});	
			});
			
			$("#can").bind("vclick",function(e){
				console.log("vclick() called.");
				var xy = getBodyOffset(e);
				
				var x = xy.x-this.offsetLeft, 
				y = xy.y-this.offsetTop;
				
				self.onClick({x:x,y:y}); 	
			});
		},
		onMouseMove:function(pos){ 
			console.log("onMouseMove() called.x="+pos.x+";y="+pos.y);
			if(this.isButtonDown){ 
				var p = this.toolbarspos; 
				for(var i in p){  
					if(pos.x >= p[i].x 
					&& pos.x <= p[i].x+p[i].w 
					&& pos.y >= p[i].y 
					&& pos.y <= p[i].y+p[i].h){return;} 
				}
				if(this.curDrawingType == this.type_line){
					this.context.lineTo(pos.x,pos.y); 
					this.context.stroke(); 	
				}else if(this.curDrawingType == this.type_eraser){	
					this.context.clearRect(pos.x,pos.y,5,5);
				} 
				
				this.lastX = pos.x; 
				this.lastY = pos.y; 
				this.curStroker.path.push(pos); 
			} 
		},
		onMouseDown:function(event,pos){ 
		console.log("onMouseDown() called.");
			 
			var p = this.toolbarspos; 
			for(var i in p){ 
			if(pos.x >= p[i].x 
			&& pos.x <= p[i].x+p[i].w 
			&& pos.y >= p[i].y 
			&& pos.y <= p[i].y+p[i].h){ 
			return; 
			} 
			} 
			this.isButtonDown = true; 
			
			this.lastX = pos.x; 
			this.lastY = pos.y; 
			this.context.beginPath(); 
			this.context.moveTo(this.lastX,this.lastY);
			this.curStroker.type = this.curDrawingType;
			this.curStroker.color = this.curColor; 
			this.curStroker.path.push(pos); 
			 
		},onMouseUp:function(event,pos){ 
		console.log("onMouseUp() called.");
			 
			var p = this.toolbarspos; 
			for(var i in p){ 
				if(pos.x >= p[i].x 
				&& pos.x <= p[i].x+p[i].w 
				&& pos.y >= p[i].y 
				&& pos.y <= p[i].y+p[i].h){return;} 
			} 
			this.isButtonDown = false; 
			this.historyStroker.push(this.curStroker); 
			this.curStroker = {color:this.curColor,path:[],type:this.curDrawingType,time:0}; 
			
		},
		ResetDrawAll:function(){ 
		console.log("ResetDrawAll() called.");
			
			this.context.clearRect(0,0,500,500); 
			this.ResetDrawCentre(); 
			this.ResetDrawToolbar(); 
		}, 
		ResetDrawCentre:function(){ 
			var p = this.historyStroker,p2, 
			curColor = this.context.strokeStyle; 
			for(var i=0; i< p.length;i++){ 
				this.context.strokeStyle = p[i].color; 
				this.context.beginPath(); 
				for(var t=0; t<p[i].path.length;t++){ 
					p2 = p[i].path[t]; 
					if(t==0) this.context.moveTo(p2.x,p2.y);
					 
						if(p[i].type == this.type_line){
							this.context.lineTo(p2.x,p2.y); 
							this.context.stroke();  	
						}else if(p[i].type == this.type_eraser){
							this.context.clearRect(p2.x,p2.y,5,5);
							this.context.stroke();  
						}					 
					 
					
				}
				this.context.closePath(); 
				this.context.beginPath(); 
			} 
			this.context.strokeStyle = curColor; 
		},
		ResetDrawToolbar:function(){
		console.log("ResetDrawToolbar() called."); 
			var curcolor = this.context.fillStyle; 
			for(var i=0; i<this.option.colors.length;i++){ 
				this.context.fillStyle = this.option.colors[i]; 
				if(this.curColor == this.context.fillStyle){ 
					this.context.fillRect(i*35+5,2,30,20); 
					this.toolbarspos[i] ={x:i*35+5,y:2,w:30,h:20}; 
				}else{ 
					this.context.fillRect(i*35+5,5,30,20); 
					this.toolbarspos[i] = {x:i*35+5,y:5,w:30,h:20}; 
				} 
				this.context.stroke(); 
			} 
			this.context.fillStyle = curcolor; 
		},
		onClick:function(pos){
			console.log("onClick() called.");
			var p = this.toolbarspos; 
			for(var i in p){ 
			if(pos.x >= p[i].x 
			&& pos.x <= p[i].x+p[i].w 
			&& pos.y >= p[i].y 
			&& pos.y <= p[i].y+p[i].h){ 
			this.curColor = this.option.colors[i];
			this.curDrawingType = this.type_line;
			this.context.strokeStyle = this.curColor; 
			this.ResetDrawAll(); 
				} 
			} 
		},
		onEraser:function(){
			console.log("onEraser called.");
			this.curDrawingType = this.type_eraser;
		} 
	};
	
	function eraserOn(){
		console.log("eraserOn() called.");
		drawer.onEraser();
	}
	
</script>
</head>
<body >
	<h2 style="padding-left: 20px">canvas</h2>
	<canvas id="can" width="300" height="500" ></canvas>
	<div>
		<a href="javascript:eraserOn();"> <img src="./css/images/eraser_off.png" /></a>
	</div>
</body>
</html>